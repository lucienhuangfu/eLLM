use num_traits::Float;
use std::ptr;
use std::ops::{Add, Mul};
const SQRT_2_DIV_PI : f32 = (0.7978845608028654f32);



pub fn gelu<T: Float>(input_ptr: *const T, output_ptr: *mut T, length: usize) 

{
    unsafe {
        for (ptr1, ptr2) in (0..length).map(|x| (input_ptr.add(x), output_ptr.add(x))) {
            let x = *ptr1;
            let y = (x + T::from(0.044715f32).unwrap() * x * x * x) * T::from(SQRT_2_DIV_PI).unwrap();
            let y2 = T::from(0.5f32).unwrap() * x * (T::from(1.0f32).unwrap() + y.tanh());
            ptr::write(ptr2, y2);
        }
    }
}

#[cfg(test)]
mod tests {
    use approx::assert_ulps_eq;
    use super::*;

    #[test]
    fn test_gelu() {
        let v1: [f32; 18] = [0.3136247992515564,
        -2.6968541145324707,
        0.7449121475219727,
        -0.3058519959449768,
        -1.034066915512085,
        -0.985573410987854,
        -0.5345404744148254,
        -1.3619849681854248,
        0.3012881577014923,
        0.8911539912223816,
        -1.2453598976135254,
        -0.3054046630859375,
        0.5982641577720642,
        -0.21695956587791443,
        -0.0798346996307373,
        -0.7486835718154907,
        0.6165731549263,
        -1.0666285753250122];
        let mut output = [0.0f32; 18];
        let result: [f32; 18] = [0.1954157054424286,
        -0.008965473622083664,0.5748836994171143,
        -0.11618322879076004,
        -0.15584588050842285,
        -0.15997932851314545,
        -0.15850451588630676,
        -0.11818332970142365,
        0.18631485104560852,
        0.7249078154563904,
        -0.13285332918167114,
        -0.11606530100107193,
        0.4338094890117645,
        -0.08984798192977905,
        -0.03737737238407135,
        -0.1700376570224762,
        0.4508279263973236,
        -0.15277788043022156];
        
        gelu(v1.as_ptr(), output.as_mut_ptr(), v1.len());
        assert_ulps_eq!(output[..], result[..], max_ulps=4)

    }
}